---
title: JVM.11 后端编译与优化
date: 2023-11-14 15:55:48
categories:
  - 深入理解JVM
tags:
  - jvm
  - 编译优化
---


## 概述

如果我们把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话， 那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相 关的二进制机器码，它都可以视为整个编译过程的后端。

无论是提前编译器抑或即时编译器，都不是Java虚拟机必需的组成部分，《Java虚拟机规范》中从来没有规定过虚拟机内部必须要包含这些编译器，更没有限定或指导这些编译器应该如何去实现。

## 即时编译器 JIT

目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过解释器 （Interpreter）进行解释执行的，**当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”**（Hot Spot Code），为了提高热点代码的执行效率，在运行时，**虚拟机将会把这些代码编译成本地机器码**，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。

### 解释器与编译器

尽管并不是所有的Java虚拟机都采用解释器与编译器并存的运行架构，但目前主流的商用Java虚拟 机，譬如HotSpot、OpenJ9等，内部都同时包含解释器与编译器，解释器与编译器两者各有优势：

- 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。
- 当程序 启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少 解释器的中间损耗，获得更高的执行效率。
- 当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。

![image-20220118205047328](https://cdn.astero.xyz/img/202201182050430.png)

###  编译对象与触发条件

运行过程中会被即时编译器编译的目标是“热点代码”，包括：

- 被多次调用的方法。
- 被多次执行的循环体。

对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。

要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”（Hot Spot Code Detection），其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主流的热点探测判定方式有两种，分别是：

- 基于采样的热点探测（Sample Based Hot Spot Code Detection）：虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。
- 基于计数器的热点探测（Counter Based Hot Spot Code Detection）：虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。

为了实现热点计数，`HotSpot`为每个方法准备了 两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter，“回边”的意思就是指在循环边界往回跳转）。

![image-20220118224321681](https://cdn.astero.xyz/img/202201182243765.png)

![image-20220118224430969](https://cdn.astero.xyz/img/202201182244017.png)

### 编译过程

在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而**编译动作则在后台的编译线程中进行**。

#### 客户端编译器

三段式，局部优化：

- 在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representation，HIR，即与目标机器指令集无关的中间表示）。在字节码上完成一部分基础优化，如方法内联、 常量传播等优化将会在字节码被构造成HIR之前完成。
- 第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。
- 最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。

![image-20220118225022986](https://cdn.astero.xyz/img/202201182250034.png)

#### 服务端编译

是一个能容忍很高优化复杂度的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的 优化强度。它会执行大部分经典的优化动作，如：**无用代码消除**（Dead Code Elimination）、**循环展开** （Loop Unrolling）、**循环表达式外提**（Loop Expression Hoisting）、**消除公共子表达式**（Common Subexpression Elimination）、**常量传播**（Constant Propagation）、**基本块重排序**（Basic Block Reordering）等，还会实施一些与Java语言特性密切相关的优化技术，如**范围检查消除**（Range Check Elimination）、**空值检查消除**（Null Check Elimination，不过并非所有的空值检查消除都是依赖编译器 优化的，有一些是代码运行过程中自动优化了）等。

### 实战：查看及分析即时编译结果

## 提前编译器

尽管Android并不能直接等同于Java，但两者毕竟有着深厚渊源，提前编译在**Android**上的革命与崛 起也震撼到了Java世界。在某些领域、某些人眼里，只要能获得更好的执行性能，什么平台中立性、 字节膨胀、动态扩展，一切皆可舍弃，唯一的问题就只有“提前编译真的会是获得更高性能的银弹吗？”

### 提前编译的优劣得失

现在提前编译产品和对其的研究有着两条明显的分支：

- 一条分支是做与传统C、C++编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作；
- 另外一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器 其他Java进程使用）时直接把它加载进来使用。

尽管即时编译在时间和运算资源方面的劣势是无法忽视的，但其依然有自己的优势。

- 性能分析制导优化（Profile-Guided Optimization，PGO）：只有运行的时候才能真正确定“热点代码”；
- 激进预测性优化（Aggressive Speculative Optimization）：可以做概率题，大不了重来，提前编译则不行；
- 链接时优化（Link-Time Optimization，LTO）：跨链接库边界的调用可以用内联来优化；

### 实战：Jaotc的提前编译

## 编译器优化技术

编译器的目标虽然是做 由程序代码翻译为本地机器码的工作，但其实难点并不在于能不能成功翻译出机器码，输出代码优化质量的高低才是决定编译器优秀与否的关键。

### 优化技术概览

![image-20220118232703809](https://cdn.astero.xyz/img/202201182327897.png)

![image-20220118232728662](https://cdn.astero.xyz/img/202201182327736.png)

### 方法内联

**编译器最重要的优化手段**，方法内联的优化行为理解起来是没有任何困难的，不过就是把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用而已。

### 逃逸分析

### 公共子表达式消除

### 数组边界检查消除

## 实战：深入理解Graal编译器