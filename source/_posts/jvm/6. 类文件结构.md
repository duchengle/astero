---
title: JVM.06 类文件结构
date: 2023-11-09 15:55:48
tags:
  - jvm
  - 类文件
---

## 概述

由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展， 把我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与**操作系统和机器指令集无关的、平台中立的格式**作为程序编译后的存储格式。

## 无关性的基石

各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——**字节码（Byte Code）** 是构成平台无关性的基石；同时，JVM设计之初就考虑过执行其他语言的程序，如现在的Groovy，Scala，Kotlin等。

- 平台无关性：Java字节码
- 语言无关性：Java虚拟机规范

Java虚拟机不与包括Java语言在内的任何程序语言绑定，它**只与“Class文件”这种特定的二进制文件格式所关联**，Class文件中包含了Java虚拟机**指令集**、**符号表**以及若干其他辅助信息。

> 基于安全方面的考虑，《Java虚拟机规范》中要求在Class文件必须应用许多强制性的语法和结构化约束，但图灵完备的字节码格式，保证了任意一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，以Class文件作为他们产品的交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把它们的源程序代码编译成Class文件。虚拟机丝毫不关心Class的来源是什么语言。

![image-20220107212949459](https://cdn.astero.xyz/img/202201072129607.png)

Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了**字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行**。因此，有一 些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于Java的语言特性提供了发挥空间。

即：

<p style="text-align: center;color: blue;font-weight: bold">字节码 > Java</p>

## Class类文件的结构

Java技术能够一直保持着非常良好的向后兼容性，Class文件结构的稳定功不可没。

任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。

Class文件是一组以**8个字节**为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储（**即与x86相反的Big-Endian**）。

> 根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：“无符号数”和“表”。后面的解析都要以这两种数据类型为基 础，所以这里笔者必须先解释清楚这两个概念。 ·无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个 字节的**无符号数**，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串 值。 ·表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名 都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视 作是一张表，这张表由下表所示的数据项按严格顺序排列构成。

![image-20220107215947469](https://cdn.astero.xyz/img/202201072159523.png)

### 魔数与Class文件的版本

每个Class文件的**头4个字节**被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为 一个能被虚拟机接受的Class文件。

> 不仅是Class文件，很多文件格式标准中都有使用魔数来进行身份识别的习惯，譬如图片格式，如GIF或者JPEG等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。

Class文件的魔数是：

<p style="text-align: center;color: blue;font-weight: bold">0xCAFEBABE</p>

紧接着魔数的**4个字节**存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。

**高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件**，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class 文件。

> 关于次版本号，曾经在现代Java（即Java 2）出现前被短暂使用过，JDK 1.0.2支持的版本45.0～ 45.3（包括45.0～45.3）。JDK 1.1支持版本45.0～45.65535，从JDK 1.2以后，直到JDK 12之前次版本 号均未使用，全部固定为零。而到了JDK 12时期，由于JDK提供的功能集已经非常庞大，有一些复杂的新特性需要以“公测”的形式放出，所以设计者重新启用了副版本号，将它用于标识“技术预览版”功能特性的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号标识为65535，以便Java虚拟机在加载类文件时能够区分出来。

### 常量池

**紧接着主、次版本号之后的是常量池入口**，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是**占用Class文件空间最大的数据项目之一**，另外，它还是在Class文件中第一个出现的表类型数据项目。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据（**2个字节**），代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始的；如果该值为`n`，则常量池中有 `n-1` 项常量，索引为 `1` ~ `n-1`。

常量池中主要存放两大类常量：**字面量（Literal）和符号引用（Symbolic References）**。**字面量**比较接近于Java语言层面的常量概念，如：

- 文本字符串；
- 被声明为final的常量值等；

而符号引用则属于编译原理方面的概念，主要包括下面几类常量：

- 被模块导出或者开放的包（Package）
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符
- 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
- 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是**在虚拟机加载Class 文件的时候进行动态连接**。也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

常量池中**每一项常量都是一个表**，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量，为了支持Java模块化系统 （Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，所以截至JDK 13，常量表中分别有17种不同类型的常量。这17类表都有一个共同的特点，表结构起始的第一位是个**u1类型的标志位**（tag，取值见表6-3中标 志列），代表着当前常量属于哪种常量类型。17种常量类型所代表的具体含义如表6-3所示。

![image-20220107220251561](https://cdn.astero.xyz/img/202201072202638.png)

> 由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名 称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的 最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。

在JDK的bin目录中，Oracle公司已经为我们 准备好一个专门用于分析Class文件字节码的工具：**javap**。

```java
javap -verbose DemoClass
```

### 访问标志

在常量池结束之后，紧接着的**2个字节**代表**访问标志（access_flags）**，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class**是类还是接口**；**是否定义为public类型**；**是否定义为abstract 类型**；如果是类的话，**是否被声明为final**；等等。

![image-20220107221132348](https://cdn.astero.xyz/img/202201072211409.png)

### 类索引、父类索引与接口索引集合

类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合 （interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定**该类型的继承关系**。

类索引用于确定这个类的**全限定名**，父类索引用于确定这个类的**父类的全限定名**。由于Java语言不允许多重继承，所以**父类索引只有一个**，除了java.lang.Object之外，所有的Java类都有父类，因此除了 java.lang.Object外，所有Java类的父类索引都不为0。

**接口索引集合**就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是 extends关键字）后的接口顺序**从左到右**排列在接口索引集合中。

对于**接口索引集合**，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。

### 字段表集合

字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）**包括类级变量以及实例级变量**，但不包括在方法内部声明的局部变量。

字段可以包括的修饰符有：

- 字段的作用域（public、private、protected修饰 符）
- 是实例变量还是类变量（static修饰符）
- 可变性（final）
- 并发可见性（volatile修饰符，是否强制从主内存读写）
- 可否被序列化（transient修饰符）
- 字段数据类型（基本类型、对象、数组）、
- 字段名称
- 初始默认值（如果有）

上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

字段表集合中**不会列出从父类或者父接口中继承而来的字段**，但有可能出现原本Java代码之中不 存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。

另外，**在Java语言中字段是无法重载的**，两个字段的数据类型、修饰符不管是否相同，都必须使 用不一样的名称，**但是对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的**。

![image-20220108214834413](https://cdn.astero.xyz/img/202201082148493.png)

### 方法表集合

Class文件存储格式中**对方法的描述与对字段的描述采用了几乎完全一致的方式**，方法表的结构如同字段表一样，依次包括**访问标志（access_flags）**、**名称索引（name_index）**、**描述符索引（descriptor_index）**、**属性表集合（attributes）**几项，如表6-11所示。这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。

![image-20220108220535326](https://cdn.astero.xyz/img/202201082205363.png)

因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了 ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract 关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、 ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见 表6-12。

![image-20220108220617391](https://cdn.astero.xyz/img/202201082206450.png)

方法里的Java代码，经过Javac编译器编译成字节码指令之 后，存放在**方法属性表集合中**一个名为“Code”的属性里面。

> 在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求 必须拥有一个与原方法不同的特征签名。特征签名是指一个方法中各个参数在常量池中的字段符号 引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值 的不同来对一个已有方法进行重载的。
>
> 但是在Class文件格式之中，特征签名的范围明显要更大一些， 只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签 名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

### 属性表集合

属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以 携带自己的属性表集合，以描述某些场景专有的信息。 与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一 些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识 的属性。为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应 当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项， 这些属性具体见表6-13。后文中将对这些属性中的关键的、常用的部分进行讲解。

![image-20220108221511780](https://cdn.astero.xyz/img/202201082215799.png)

![image-20220108221447840](https://cdn.astero.xyz/img/202201082214925.png)

![image-20220108221531944](https://cdn.astero.xyz/img/202201082215035.png)

对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示， 而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。 一个符合规则的属性表应该满足表6-14中所定义的结构。

![image-20220108221558272](https://cdn.astero.xyz/img/202201082215300.png)

#### Code属性

Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。 Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽 象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。

![image-20220108222104525](https://cdn.astero.xyz/img/202201082221572.png)

- attribute_name_index：指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它 代表了该属性的属性名称；

- attribute_length：指示了属性值的长度，由于属性名称索引和属性长度值一共6个字节，因此属性值的长度为属性表的长度减6；

- max_stack：操作数栈深度的最大值；JVM根据该值分配栈帧中的操作栈深度；

- max_locals：局部变量表所需的存储空间，单位为槽（Slot）；Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，存储空间可以重用， 根据**同时生存的最大局部变量数量和类型**计算出max_locals的大小。；

- code_length：字节码长度；虽然它是一个u4类型的长度值，理论上最大值可以达 到2的32次幂，但是《Java虚拟机规范》中明确限制了**一个方法不允许超过65535条字节码指令**，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译（在JSP编译时可能会遇到）；

- code：存储字节码指令的一系列字节流；每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析；

  > 我们知道一个u1 数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令。目前， 《Java虚拟机规范》已经定义了其中约200条编码值对应的指令含义。

- exception_table_length：异常表长度，这里指显式异常；
- exception_table：异常表；从 start_pc 到 end_pc（不包含）中出现的catch_type异常或其子类的异常转到handler_pc处理；catch_type = 0 表示所有异常，即： Exception；

![msedge_WBMm55qnfU](https://cdn.astero.xyz/img/202201082239087.png)

#### Exceptions属性

这里的Exceptions属性是在方法表中与Code属性平级的一项属性，读者不要与前面刚刚讲解完的异 常表产生混淆。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也 就是方法描述时在throws关键字后面列举的异常。它的结构见表6-17。

![image-20220108225935680](https://cdn.astero.xyz/img/202201082259715.png)

此属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示；exception_index_table是一个指向常量池中 CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。

#### LineNumberTable属性

LineNumberTable属性用于描述**Java源码行号与字节码行号（字节码的偏移量）之间的对应关系**。 它并**不是**运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：lines 选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要影 响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。

![image-20220108230212180](https://cdn.astero.xyz/img/202201082302201.png)

![image-20220108230200028](https://cdn.astero.xyz/img/202201082302061.png)

#### LocalVariableTable及LocalVariableTypeTable属性

LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。

![image-20220108230416517](https://cdn.astero.xyz/img/202201082304553.png)

其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构如表6-20所示。

![image-20220108230447124](https://cdn.astero.xyz/img/202201082304158.png)

- start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围； 

- name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符；
- index是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时 （double和long），它占用的变量槽为index和index+1两个；

> 引入泛型以后，LocalVariableTable属性增加了一个“姐妹属性”—— LocalVariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉，描 述符就不能准确描述泛型类型了。因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。

#### SourceFile及SourceDebugExtension属性

SourceFile属性用于记录**生成这个Class文件的源码文件名称**。这个属性也是可选的，可以使用Javac 的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。

为了方便在编译器和动态生成的Class中加入供程序员使用的自定义内容，在JDK 5时，新增了 `SourceDebugExtension`属性用于存储额外的代码调试信息。

#### ConstantValue属性

ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类 变量）才可以使用这项属性。类似“int x=123”和“static int x=123”这样的变量定义在Java程序里面是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对非static类型的变量（也就是 实例变量）的赋值是在实例构造器()方法中进行的；而对于类变量，则有两种方式可以选择：在 类构造器()方法中或者使用ConstantValue属性。

#### InnerClasses属性

InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。InnerClasses属性的结构如表6-24所示。

![image-20220108232938419](https://cdn.astero.xyz/img/202201082329452.png)

数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个 inner_classes_info表进行描述。inner_classes_info表的结构如表6-25所示。

![image-20220108233023966](https://cdn.astero.xyz/img/202201082330000.png)

#### Deprecated及Synthetic属性

Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值 的概念。 Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通 过代码中使用“@deprecated”注解进行设置。 Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在 JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 ACC_SYNTHETIC标志位。

#### StackMapTable属性

StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新**类型检查验证器**（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。

StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。

![image-20220110195218580](https://cdn.astero.xyz/img/202201101952617.png)

#### Signature属性

Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段 表和方法表结构的属性表中。在JDK 5里面大幅增强了Java语言的语法，在此之后，任何类、接口、初 始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（Parameterized Type），则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类 型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编 译（类型变量、参数化类型）在编译之后都通通被擦除掉。

**现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性**。

#### BootstrapMethods属性

#### MethodParameters属性

MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。 MethodParameters的作用是**记录方法的各个形参名称和信息**。

#### 模块化相关属性

JDK 9的一个重量级功能是Java的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能。

#### 运行时注解相关属性

RuntimeVisibleAnnotations是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注 解，当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。

![image-20220110195848109](https://cdn.astero.xyz/img/202201101958140.png)

![image-20220110195904124](https://cdn.astero.xyz/img/202201101959152.png)

## 字节码指令简介

Java虚拟机的指令由**一个字节长度**的、代表着某种特定操作含义的数字（称为操作码，Opcode） 以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。由于Java虚拟机采用**面向操作数栈**而不是面向寄存器的架构，所 以大多数指令都不包含操作数，只有一个操作码，**指令参数都存放在操作数栈中**。

字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着**指令集的操作码总数不能够超过256条**；又由于 Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数 据时，不得不在运行时从字节中重建出具体数据的结构。这种操作在某种程度上会导致解释执行字节码时将损失一些性能，但这样做的优势也同样明显： 放弃了操作数长度对齐，就意味着可以省略掉大量的填充和间隔符号；用一个字节来代表操作码， 也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效率的设计是由Java语 言设计之初主要面向网络、智能家电的技术背景所决定的，并一直沿用至今。

> 譬如要将一个16位长度的无符号整数使用两 个无符号字节存储起来（假设将它们命名为byte1和byte2），那它们的值应该是这样的：
>
> ```java
> (byte1 << 8) | byte2
> ```

### 字节码与数据类型

在Java虚拟机的指令集中，**大多数指令都包含其操作所对应的数据类型信息**。

> 举个例子，iload指 令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。

因为Java虚拟机的操作码长度只有一字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么指令的数量恐怕就会超出一字节所能表示的数量范围了。

因此，Java虚拟机的指令集**对于特定的操作只提供了有限的类型相关指令去支持它**，换句话说，指令集将会被故意设计成非完全独立的。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。

![image-20220110201300971](https://cdn.astero.xyz/img/202201102013993.png)

![image-20220110201312214](https://cdn.astero.xyz/img/202201102013262.png)

![image-20220110201353053](https://cdn.astero.xyz/img/202201102013095.png)

> 请注意，从表6-40中看来，大部分指令没有支持整数类型byte、char和short，甚至没有任何指令 支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为 相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类 似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来 处理。**因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。**

将字节码操作按用途大致分为9类：

- 加载和存储指令
- 运算指令
- 类型转换指令
- 对象创建与访问指令
- 操作数栈管理指令
- 控制转移指令
- 方法调用和返回指令
- 异常处理指令
- 同步指令



### 加载和存储指令

加载和存储指令用于将数据在栈帧中的**局部变量表**和**操作数栈**之间来回传输，这类指令包括：

- 将一个局部变量加载到操作栈：iload、iload\_<n>_、lload、lload_\_<n>、fload、fload\_<n>_、dload、 dload_\_<n>、aload、aload\_<n>
- 将一个数值从操作数栈存储到局部变量表：istore、istore\_<n>_、lstore、lstore_\_<n>、fstore、 fstore\_<n>_、dstore、dstore_\_<n>、astore、astore\_<n>
- 将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst\_<i>、lconst\_<l>、fconst\_<f>_、dconst_\_<d>
- 扩充局部变量表的访问索引的指令：wide

### 运算指令

算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

- 整数运算：只有除0或者除0取余会抛异常；
- 浮点数运算：IEEE  754

包括：

- 加法指令：iadd、ladd、fadd、dadd 
- 减法指令：isub、lsub、fsub、dsub 
- 乘法指令：imul、lmul、fmul、dmul 
- 除法指令：idiv、ldiv、fdiv、ddiv 
- 求余指令：irem、lrem、frem、drem 
- 取反指令：ineg、lneg、fneg、dneg 
- 位移指令：ishl、ishr、iushr、lshl、lshr、lushr 
- 按位或指令：ior、lor 
- 按位与指令：iand、land 
- 按位异或指令：ixor、lxor 
- 局部变量自增指令：iinc 
- 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp

> 在对long类型数值进行比较时，Java虚拟机采用带符号的比较方式，而对浮点数值进行比较时 （dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（Nonsignaling Comparison）方式进行。
>
> 可以研究一下Java中浮点数的近似运算。

### 类型转换指令

类型转换指令可以**将两种不同的数值类型相互转换**，这些转换操作一般用于实现用户代码中的**显式类型转换**操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型 一 一对应的问题。

Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的**宽化类型转换**（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）： 

- int类型到long、float或者double类型 
- long类型到float、double类型 
- float类型到double类型 

与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。

> 在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。

Java虚拟机将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，必须遵循以下转换规则： 

- 如果浮点值是NaN，那转换结果就是int或long类型的0。 
- 如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在目标类型T（int或long）的表示范围之类，那转换结果就是v；否则，将根据v的符号，转换为T所能表 示的最大或者最小正数。

尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是《Java虚拟机规 范》中明确规定数值类型的窄化转换指令**永远不可能导致虚拟机抛出运行时异常**。

### 对象创建与访问指令

对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括： 

- 创建类实例的指令：new 
- 创建数组的指令：newarray、anewarray、multianewarray 
- 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的 指令：getfield、putfield、getstatic、putstatic 
- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aaload 
- 将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、 dastore、aastore 
- 取数组长度的指令：arraylength 
- 检查类实例类型的指令：instanceof、checkcast

### 操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括： 

- 将操作数栈的栈顶一个或两个元素出栈：pop、pop2 
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、 dup2_x1、dup_x2、dup2_x2 
- 将栈最顶端的两个数值互换：swap

### 控制转移指令

控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括：

- 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne 
- 复合条件分支：tableswitch、lookupswitch （注意，这两条指令是4字节对齐的）
- 无条件分支：goto、goto_w、jsr、jsr_w、ret （jsr和ret已被禁止）

> 在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明 显标识一个数据的值是否null，也有专门的指令用来检测null值。

### 方法调用和返回指令

- invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）， 这也是Java语言中最常见的方法分派方式。 
- invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。 
- invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。 
- invokestatic指令：用于调用类静态方法（static方法）。 
- invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

**方法调用指令与数据类型无关**，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返 回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一 条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用

### 异常处理指令

在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常 状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出 ArithmeticException异常。 而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和 ret指令来实现，现在已经不用了），而是采用异常表来完成。

### 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。

**方法级的同步是隐式的**，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟 机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有锁，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放锁。在方法执行期间，执行线程持有了锁，其他任何线程都无法再获取到同一个锁。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法边界之外时自动释放。

同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。

```java
void onlyMe(Foo f) {
	synchronized(f) {
		doSomething();
	}
}
```

这段代码的字节码为：

```java
Method void onlyMe(Foo)
0 aload_1 // 将对象f入栈
1 dup // 复制栈顶元素（即f的引用）
2 astore_2 // 将栈顶元素存储到局部变量表变量槽 2中
3 monitorenter // 以栈定元素（即f）作为锁，开始同步
4 aload_0 // 将局部变量槽 0（即this指针）的元素入栈
5 invokevirtual #5 // 调用doSomething()方法
8 aload_2 // 将局部变量Slot 2的元素（即f）入栈
9 monitorexit // 退出同步
10 goto 18 // 方法正常结束，跳转到18返回
13 astore_3 // 从这步开始是异常路径，见下面异常表的Taget 13
14 aload_2 // 将局部变量Slot 2的元素（即f）入栈
15 monitorexit // 退出同步
16 aload_3 // 将局部变量Slot 3的元素（即异常对象）入栈
17 athrow // 把异常对象重新抛出给onlyMe()方法的调用者
18 return // 方法正常返回
    
Exception table:
From To Target Type
4 10 13 any
13 16 13 any
```

编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行monitorexit指令。

## 公有设计，私有实现

《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。

剩下的，大家自由发挥。

虚拟机实现的方式主要有以 下两种： 

- 将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集； 
- 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即**即时编译器**代码生成技术）。

## Class文件结构的发展

Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。